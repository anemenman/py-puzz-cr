import heapq

"""
Из n отсортированных массивов получаем один отсортированный(общее решение)

1) Минимальная куча (min-heap): Мы используем heapq для хранения текущих минимальных элементов из каждого массива.
2) Инициализация: Добавляем первый элемент каждого массива в кучу.
3) Слияние:
Извлекаем минимальный элемент из кучи и добавляем его в результирующий массив.
Если в массиве, из которого был извлечен элемент, есть следующий элемент, добавляем его в кучу.
Повторяем процесс до тех пор, пока куча не станет пустой.

Время выполнения
Время выполнения данного алгоритма составляет (O(N*log k)), где (N) — общее количество элементов во всех массивах, 
а (k) — количество массивов. Это более эффективно, чем простой подход с использованием полного объединения 
и последующей сортировки.
"""


def merge_sorted_arrays(arrays):
    # Создаем кучу для хранения (значение, индекс массива, индекс внутри массива)
    min_heap = []

    # Инициализируем кучу с первыми элементами каждого массива
    for i, arr in enumerate(arrays):
        if arr:  # Проверяем, что массив не пустой
            heapq.heappush(min_heap, (arr[0], i, 0))

    merged = []

    while min_heap:
        value, arr_index, element_index = heapq.heappop(min_heap)
        merged.append(value)

        # Если в массиве есть следующий элемент, добавляем его в кучу
        if element_index + 1 < len(arrays[arr_index]):
            next_value = arrays[arr_index][element_index + 1]
            heapq.heappush(min_heap, (next_value, arr_index, element_index + 1))

    return merged


# Пример использования
arrays = [
    [1, 4, 5],
    [1, 3, 4],
    [2, 6]
]

merged_list = merge_sorted_arrays(arrays)
print(merged_list)  # Вывод: [1, 1, 2, 3, 4, 4, 5, 6]
